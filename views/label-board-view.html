<style>
  #scene {
    width: 100%;
    height: 100%;
  }
</style>

<div id="scene"></div>

<script src="/node_modules/@hatiolab/things-scene/things-scene-min.js"></script>
<script src="/headless-scene-components.js"></script>
<script>
  var model = <%- JSON.stringify(model) %>;

  var el = document.getElementById('scene')
  var s = scene.create({
    model,
    mode: 0,
    refProvider: null //self.provider
  })
  s.target = el

  function imageDataToGrf(width, height) {
    const R = 0
    const G = 1
    const B = 2
    const A = 3
    const THRESHOLD = 95

    const MAP_CODE = {
      1: 'G',
      2: 'H',
      3: 'I',
      4: 'J',
      5: 'K',
      6: 'L',
      7: 'M',
      8: 'N',
      9: 'O',
      10: 'P',
      11: 'Q',
      12: 'R',
      13: 'S',
      14: 'T',
      15: 'U',
      16: 'V',
      17: 'W',
      18: 'X',
      19: 'Y',
      20: 'g',
      40: 'h',
      60: 'i',
      80: 'j',
      100: 'k',
      120: 'l',
      140: 'm',
      160: 'n',
      180: 'o',
      200: 'p',
      220: 'q',
      240: 'r',
      260: 's',
      280: 't',
      300: 'u',
      320: 'v',
      340: 'w',
      360: 'x',
      380: 'y',
      400: 'z'
    }

    var imageData = getImageData(width, height) // 이미지 데이터

    // 이미지의 가로 한 줄당 바이트
    var bytesPerLine = width + 7 >> 3 // var bytesPerLine = Math.ceil(width / 8)

    // 바이트와 실제 너비 차이
    var diff = (bytesPerLine << 3) - width

    // GRF 사이즈 = 가로 바이트 사이즈 * 세로
    var grfSize = bytesPerLine * height

    // GRF 사이즈 만큼의 배열 생성, GRF 문자열을 만들 때 사용, 메모리 확보
    var grfArray = new Uint8Array(grfSize)

    var maxCharsOfLine = bytesPerLine << 1
    var zippedGrf = ''
    var count = 1
    var baseNibble = null
    var objectNibble = null
    var baseChar = '', textLine = ''
    var previousLine = ''

    var multi20 = 0, resto20 = 0;

    // 도트 단위 처리를 위해 이미지 크기만큼 루프
    for (var y = 0; y < height; y++) {
      for (var x = 0; x < width; x++) {
        let j = width * y + x // 현재 도트 좌표 (처리중인 도트)
        let i = j << 2 // 이미지 데이터의 도트 좌표 (도트 * 4)

        // 도트의 밝기
        let luminance = imageData[i + R] * 0.21 + imageData[i + G] * 0.71 + imageData[i + B] * 0.07
        // Alpha 값이 낮을 수록 luminance가 높아지는 것으로 본다.
        luminance = luminance + ((255 - imageData[i + A]) * (255 - luminance)) / 255

        let k = ((bytesPerLine << 3) * y + x) >> 3 // GRF 배열에서 사용할 요소 인덱스
        grfArray[k] <<= 1 // 도트 좌표 이동
        if (luminance < THRESHOLD) grfArray[k] |= 1 // THRESHOLD 값으로 칠할지 여부 판단, 어두우면 칠함

        // 4도트마다 압축 로직 적용
        if ((x & 3) == 3) {
          if (x == 3) {
            baseNibble = grfArray[k] & 0b1111
            continue
          }
          objectNibble = grfArray[k] & 0b1111 // 뒷 4자리
          if (baseNibble === objectNibble) {
            count++
          } else {
            baseChar = baseNibble.toString(16)
            if (count > 20) {
              var multi20 = Math.floor(count / 20) * 20
              var resto20 = count % 20
              textLine += MAP_CODE[multi20] || null
              if (resto20) textLine += MAP_CODE[resto20] + baseChar
              else textLine += baseChar
            } else textLine += MAP_CODE[count] + baseChar
            count = 1
            baseNibble = objectNibble
          }
        }
      }

      // 끝의 8도트는 남는 도트 수만큼 왼쪽으로 밀어줌
      var lastByteOfLine = grfArray[(y + 1) * bytesPerLine - 1]
      lastByteOfLine <<= diff

      if (diff != 0) {
        if (diff > 4) {
          if (baseNibble == (lastByteOfLine >> 4)) {
            count++
          } else {
            baseChar = baseNibble.toString(16)
            if (count > 20) {
              multi20 = Math.floor(count / 20) * 20
              resto20 = count % 20
              textLine += MAP_CODE[multi20] || null
              if (resto20) textLine += MAP_CODE[resto20] + baseChar
              else textLine += baseChar
            } else textLine += MAP_CODE[count] + baseChar
            count = 1
            baseNibble = lastByteOfLine >> 4
          }
        }
        if (baseNibble == (lastByteOfLine & 15)) {
          count++
        } else {
          baseChar = baseNibble.toString(16)
          if (count > 20) {
            multi20 = Math.floor(count / 20) * 20
            resto20 = count % 20
            textLine += MAP_CODE[multi20] || null
            if (resto20) textLine += MAP_CODE[resto20] + baseChar
            else textLine += baseChar
          }
          else textLine += MAP_CODE[count] + baseChar
          count = 1
          baseNibble = lastByteOfLine & 15
        }
      }

      var isOverTheLineMax = count >= maxCharsOfLine
      baseChar = baseNibble.toString(16)
      if (isOverTheLineMax && baseNibble == 0) textLine += ','
      else if (isOverTheLineMax && baseNibble == 0xf) textLine += '!'
      else if (count > 20) {
        multi20 = Math.floor(count / 20) * 20
        resto20 = count % 20
        textLine += MAP_CODE[multi20] || null
        if (resto20) textLine += MAP_CODE[resto20] + baseChar
        else textLine += baseChar
      }
      else textLine += MAP_CODE[count] + baseChar
      count = 1
      if (textLine == previousLine) zippedGrf += ':'
      else zippedGrf += textLine
      previousLine = textLine
      textLine = ''
    }
    return zippedGrf
  }

  function getImageData(width, height) {
    return s._container.model_layer.canvas.getContext('2d').getImageData(0, 0, width, height).data
  }

  function resize() {
    s.fit('ratio')
  }

  resize()

  addEventListener('resize', function () {
    if (requestAnimationFrame) {
      requestAnimationFrame(resize)
    } else {
      setTimeout(resize, 66)
    }
  }, false)
</script>